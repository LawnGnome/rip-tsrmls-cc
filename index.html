<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>RIP TSRMLS_CC</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">

		<!-- CSS overrides -->
		<link rel="stylesheet" href="css/style.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section id="title">
          <h2>Welcome to the new age</h2>
					<h1>RIP <code>TSRMLS_CC</code></h1>
					<h3>
						Adam Harvey
						<br>
						<a href="https://twitter.com/LGnome">@LGnome</a>
						<br>
						<a href="http://newrelic.com">New Relic</a>
					</h3>
				</section>

				<section data-background="images/Woolly_mammoth.jpg">
					<section id="php7">
						<aside class="notes">
							PHP 7 came out in December 2015. It's been kept quiet, but you
							may have heard of it.
						</aside>
					</section>

					<section id="api-churn" data-state="translucent" data-background="translucent">
						<h2>API churn</h2>
						<ul>
							<li>333 functions/macros removed</li>
							<li>410 functions/macros added</li>
						</ul>
						<aside class="notes">
							In userland, we did a good job of maintaining backward
							compatibility, but that wasn't the case for the API exposed by
							the Zend Engine and PHP itself. 333 functions is almost exactly
							one quarter of the functions and macros exposed by PHP 5.6.
						</aside>
					</section>

					<section id="api-diff" data-state="translucent" data-background="translucent">
						<h2>API churn</h2>
						<ul>
							<li>516 out of 990 functions/macros differ</li>
						</ul>
            <aside class="notes">
              Here's the more insidious bit: more than half of the functions
              that kept the same name have changed. (And that excluded
              TSRM-related noise.) Different types, different numbers of
              parameters, different return values. Most don't matter, but some
              <em>really</em> do.
            </aside>
					</section>
				</section>

        <section data-background="images/geograph-3799604-by-Peter-.jpg">
          <section id="what-do">
            <aside class="notes">
              So, now that I've thoroughly terrified you, what do you do with
              your PHP 4 or 5 era extension that your site relies on?
            </aside>
          </section>

          <section id="options" data-state="translucent" data-background="translucent">
            <h2>What do?</h2>
            <ul>
              <li>One way migration</li>
              <li>Separate branches</li>
              <li>Shared codebase</li>
              <li class="fragment">Ignore PHP 7 and hope it goes away</li>
            </ul>
            <aside class="notes">
              The way I see it, you have three real options.
              (pause)
              I guess there's a fourth.
            </aside>
          </section>
        </section>

        <section data-background="images/road-street-sign-way.jpg">
          <section id="one-way">
          </section>
          <aside class="notes">
            Let's look at the pros and cons of each in turn. First up: one way
            migration.
          </aside>

          <section id="one-way-advantages" data-state="translucent" data-background="translucent">
            <h2>Advantages</h2>
            <ul>
              <li>One time cost</li>
              <li>Conceptually simple</li>
              <li>Cleaner code</li>
            </ul>
          </section>

          <section id="one-way-disadvantages" data-state="translucent" data-background="translucent">
            <h2>Disadvantages</h2>
            <ul>
              <li>You no longer support PHP 5</li>
            </ul>
            <aside class="notes">
              Not supporting PHP 5 may not be a huge issue if you're only
              supporting something internal: if you're planning to do a hard
              cut over, that works. Although I'm not going to talk a lot about
              this option as we go on, the things I highlight are also things
              you'd want to do with this option.
            </aside>
          </section>
        </section>

        <section data-background="images/branches.jpg">
          <section id="branches">
            <aside class="notes">
              Maintaining parallel branches is another option.
            </aside>
          </section>

          <section id="branches-advantages" data-state="translucent" data-background="translucent">
            <h2>Advantages</h2>
            <ul>
              <li>Both versions are supported</li>
              <li>Able to write idiomatic code for both versions</li>
            </ul>
          </section>

          <section id="branches-disadvantages" data-state="translucent" data-background="translucent">
            <h2>Disadvantages</h2>
            <ul>
              <li>Maintenance is a pain</li>
              <li>Potentially double the work</li>
              <li>Branches may diverge over time</li>
            </ul>
            <aside class="notes">
              This might work if you have almost everything abstracted away,
              but if you do, the parts of your code that interface with PHP are
              probably so simple anyway that you could just support both
              versions in the one branch.
            </aside>
          </section>
        </section>

        <section data-background="images/hammer.jpg">
          <section id="shared">
            <aside class="notes">
              Finally (excluding ignoring PHP 7), you can run a shared codebase.
            </aside>
          </section>

          <section id="shared-advantages" data-state="translucent" data-background="translucent">
            <h2>Advantages</h2>
            <ul>
              <li>Both versions are supported</li>
              <li>Less maintenance overhead</li>
              <li>Happy users</li>
            </ul>
            <aside class="notes">
              Happy users because they can just download the latest release; cf
              memcached.
            </aside>
          </section>

          <section id="shared-disadvantages" data-state="translucent" data-background="translucent">
            <h2>Disadvantages</h2>
            <ul>
              <li>So many API changes</li>
            </ul>
            <aside class="notes">
              I'm going to delve deeper into this. There are ways you can
              mitigate the API changes &mdash; how hard it is depends a lot on
              what type of extension you're writing. Simple C library wrappers:
              not too bad. Deep voodoo magic extensions: bad (but still
              doable).
            </aside>
          </section>
        </section>

        <section id="no-really-what-do-i-do" data-background="images/geograph-3799604-by-Peter-.jpg">
					<aside class="notes">
						As I've touched on already, it depends on your use case. If you're
						doing a flag day cutover of your app, and you have an extension
						that solely exists to serve that app, you probably just want to do
						a one way migration and be done with it. Otherwise, I'd go for
						option 3: support both. Separate branches don't work in the long
						term: ask Python developers.
					</aside>
				</section>

				<section data-state="white-bg" id="compile-it" data-background="images/build.png">
					<aside class="notes">
						Whatever you choose, the best thing to start is by trying to build
						your extension. It <em>will</em> fail, but the compiler errors will
						guide you pretty well for a lot of things, and once you clear them
						up you can use your test suite to catch the rest. (You have tests,
						right?) Still, that won't pick up everything, and there are things
						that you're better off knowing about in advance. So let's get into
						it.
					</aside>
				</section>

				<section data-background="images/fix.jpg">
					<section id="problems">
						<aside class="notes">
							So we know that a lot changed. What do we need to look for when
							migrating an extension?
						</aside>
					</section>

					<section id="zval" data-state="translucent" data-background="translucent">
						<h2><code>zval</code></h2>
						<aside class="notes">
							Let's start from the inside and work our way out. Many of the
							changes that matter when working on an extension are
							fundamentally type-related, so let's start with the type that
							underpins all of PHP.
						</aside>
					</section>

					<section id="zval-struct" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
typedef struct {
	zend_uchar type;
	zend_uint  refcount__gc;
	zend_uchar is_ref__gc;
	union {
		long lval;
		double dval;
		struct {
			char *val;
			int len;
		} str;
		HashTable *ht;
		zend_object_value obj;
	} value;
} zval;
						</code></pre>
						<aside class="notes">
							Here's a simplified version of what the zval struct looks like in
							PHP 5. The important thing to remember is that each type
							corresponds to a member in the value union. Many of these values
							have changed: either in structure or in type.
						</aside>
					</section>

					<section id="zval-struct7" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
typedef struct {
	zend_value value;
	union {
		struct {
			zend_uchar type;
			...
		}
	}
} zval;
						</code></pre>
						<aside class="notes">
							Here's a simplified version of the PHP 7 zval. We'll talk about
							the specifics of the types that have changed representation after
							this, but I want you to note that the refcount and is_ref fields
							are gone. zvals are passed around by value rather than reference,
							so simple types don't need to be refcounted, and types that do
							need to be are refcounted within their values rather than the
							zval itself.
						</aside>
					</section>

					<section id="zval-long" data-state="translucent" data-background="translucent">
						<h2><code>IS_LONG</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
long lval;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_long lval;

#if defined(__LP64__) || defined(_LP64) || defined(_WIN64)
typedef int64_t zend_long;
#else
typedef int32_t zend_long;
#endif
						</code></pre>
						<aside class="notes">
							Integers are now this zend_long type, which means that integers
							are now consistently 64 bit on all 64 bit platforms, including
							Windows (which used to be an oddball). This is good, but think
							about what happens if you're on Win64 and use long (which is 32
							bit) with zend_parse_parameters().
						</aside>
					</section>

					<section id="zval-bool" data-state="translucent" data-background="translucent">
						<h2><code>IS_BOOL</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
long lval;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
#define IS_FALSE 2
#define IS_TRUE  3

ZEND_API int zend_is_true(zval *op);
						</code></pre>
						<aside class="notes">
							IS_BOOL is gone altogether! In PHP 5, it used the lval to
							indicate whether it was true or false. In PHP 7, false and true
							are separate types. The ZVAL_BOOL macro still exists for setting,
							but to check the value you either have to check the type or call
							zend_is_true().
						</aside>
					</section>

					<section id="zval-string" data-state="translucent" data-background="translucent">
						<h2><code>IS_STRING</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
struct {
	char *val;
	int len;
} str;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_string *str;
						</code></pre>
						<aside class="notes">
							Let's talk about a more interesting one. Three types are now
							pointers to other structures with their own garbage collection.
							The Zend Engine has retained the Z_STRLEN and Z_STRVAL macros,
							but there's now a string structure that gets used throughout the
							engine, not just for zvals. Let's look at it in more detail...
						</aside>
					</section>

					<section id="zend-string-struct" data-state="translucent" data-background="translucent">
						<h2><code>zend_string</code></h2>
						<pre><code class="c" data-trim>
typedef struct {
	zend_refcounted_h gc;
	zend_ulong        h;
	size_t            len;
	char              val[1];
} zend_string;
						</code></pre>
						<aside class="notes">
							Key points: lengths are now size_t, not signed int, as $DEITY
							intended. Garbage collection now takes place within the
							structure. h is a cached hash value.
						</aside>
					</section>

					<section id="zend-string-api" data-state="translucent" data-background="translucent">
						<h2><code>zend_string</code></h2>
						<pre><code class="c" data-trim>
zend_string *zend_string_alloc(size_t len, int persistent);
zend_string *zend_string_init(const char *s, size_t len, int pers);
zend_string *zend_string_dup(zend_string *s, int persistent);
void zend_string_release(zend_string *s);

uint32_t zend_string_addref(zend_string *s);
uint32_t zend_string_delref(zend_string *s);

#define ZSTR_VAL(zstr)  (zstr)-&gt;val
#define ZSTR_LEN(zstr)  (zstr)-&gt;len
						</code></pre>
						<aside class="notes">
							A new set of functions have been added to deal with zend_strings.
							These are the most important ones (the full set is in
							zend_string.h). Again, note that reference counting is done on
							the string, not the zval, so it has "methods" to deal with that.
						</aside>
					</section>

					<section id="string-duplication" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
RETURN_STRING(str, duplicate)
ZVAL_STRING(zv, str, duplicate)
add_assoc_string(zv, key, str, duplicate)
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
RETURN_STRING(str)
ZVAL_STRING(zv, str)
add_assoc_string(zv, key, str)
						</code></pre>
						<aside class="notes">
							Most macros and functions that dealt with setting strings had
							parameters indicating whether you wanted to duplicate the input.
							Those are now gone, since they have to create a zend_string
							anyway and will always duplicate. You can override this by
							instantiating the string directly using the zend_string API, but
							why would you?
						</aside>
					</section>

					<section id="string-duplication-options" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
#if ZEND_MODULE_API_NO &lt; 20151012

#undef ZVAL_STRING
#define ZVAL_STRING(zv, str) do {             \
	const char *__s = (s);                \
	int __l = strlen(str);                \
	zval *__z = (zv);                     \
	Z_STRLEN_P(__z) = l;                  \
	Z_STRVAL_P(__z) = estrndup(__s, __l); \
} while (0);

#endif
						</code></pre>
						<aside class="notes">
							Again, if you're supporting both versions, your options are kind
							of problematic. You're going to have to have compatibility
							wrappers or redefine the macros (my preference, but make sure you
							do it after including all PHP headers!). The downside is that
							it's ugly (and there's eight of them), although you can basically
							crib the implementations from the PHP 5.6 source.
						</aside>
					</section>

					<section id="zval-object" data-state="translucent" data-background="translucent">
						<h2><code>IS_OBJECT</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
typedef struct {
	zend_object_handle handle;
	const zend_object_handlers *handlers;
} zend_object_value;

zend_object_value obj;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_object *obj;
						</code></pre>
						<aside class="notes">
							Another new type! I'm going to talk more about class and object
							handling later, but let's focus for now on the representation. In
							PHP 5, zend_object_value is a small inline structure with an
							object handle, which is an index into a hash table.
						</aside>
					</section>

					<section id="zend-object" data-state="translucent" data-background="translucent">
						<h2><code>zend_object</code></h2>
						<pre><code class="c" data-trim>
typedef struct {
	zend_refcounted_h           gc;
	uint32_t                    handle;
	zend_class_entry           *ce;
	const zend_object_handlers *handlers;
	HashTable                  *properties;
	zval                        properties_table[1];
} zend_object;
						</code></pre>
						<aside class="notes">
							This is a structure that it's probably rare that you'll poke
							directly, but again: refcounting is done on the object. The class
							entry and properties are now inline, which improves caching and
							performance. Note that this is variable length, though: this is
							important if you're overriding the create_object handler. I won't
							get into the API, because it hasn't changed much.
						</aside>
					</section>

					<section id="zval-resource" data-state="translucent" data-background="translucent">
						<h2><code>IS_RESOURCE</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
long lval;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_resource *res;
						</code></pre>
						<aside class="notes">
							Finally, resources change from being indexes stored in the long
							value to being pointers to their own structures.
						</aside>
					</section>

					<section id="zend-resource" data-state="translucent" data-background="translucent">
						<h2><code>zend_resource</code></h2>
						<pre><code class="c" data-trim>
typedef struct {
	zend_refcounted_h gc;
	int               handle;
	int               type;
	void             *ptr;
};
						</code></pre>
						<aside class="notes">
							This one's actually a huge improvement: the resource type is now
							kept inline. The bad news is that the API has changed, which I'll
							talk more about later.
						</aside>
					</section>

					<section id="zval-new-types" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
#define IS_UNDEF     0

#define IS_REFERENCE 10
zend_reference *ref;
						</code></pre>
						<aside class="notes">
							Finally, there are a bunch of new types. The two that are
							important are UNDEF, which is for undefined variables (as the
							name might suggest), and REFERENCE, which replaces the built in
							is_ref field in the zval with a pointer to a refcounted
							structure (remembering the earlier point about not having
							refcounting in the zval itself).
						</aside>
					</section>
				</section>

				<section data-background="images/parameters.jpg">
					<section id="parameter-parsing">
						<aside class="notes">
							Let's look at more concrete things you need to audit. We'll start
							with parameter parsing, since that's not going to be caught by
							the compiler.
						</aside>
					</section>

					<section id="zpp-string" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
char *str;
int len;

zend_parse_parameters(ZEND_NUM_ARGS(), "s", &amp;str, &amp;len);
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
char *str;
size_t len;

zend_parse_parameters(ZEND_NUM_ARGS(), "s", &amp;str, &amp;len);
						</code></pre>
						<aside class="notes">
							For example: as I mentioned earlier, string lengths are now
							size_t. If you don't change the length variable to size_t, you
							get interesting looking segfaults on 64 bit platforms. This one's
							insidious.
						</aside>
					</section>

					<section id="zpp-string-options" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
#if ZEND_MODULE_API_NO &gt;= 20151012
typedef size_t zend_string_len_t;
#else
typedef int zend_string_len_t;
#endif

char *str;
zend_string_len_t len;
zend_parse_parameters(ZEND_NUM_ARGS(), "s", &amp;str, &amp;len);
						</code></pre>
						<aside class="notes">
							How do you deal with this if you want to support both versions?
							You can do some macro and typedef magic. (I'm going to show
							examples of how you might do this yourself, but bear in mind that
							there are libraries that will abstract at least some of this for
							you in existence. It's important to know how the sausage is made,
							but you may not have to write much of this shim code yourself.)
						</aside>
					</section>

					<section id="zpp-long" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
#if ZEND_MODULE_API_NO &lt; 20151012
typedef long zend_long;
#endif

zend_long l;
zend_parse_parameters(ZEND_NUM_ARGS(), "l", &amp;l);
						</code></pre>
						<aside class="notes">
							I'd do something similar for zend_long too.
						</aside>
					</section>
				</section>

				<section data-background="images/array.jpg">
					<section id="arrays">
						<aside class="notes">
							Arrays aren't hugely different, but there are two changes of
							note, and one will bite you silently if you're not careful.
						</aside>
					</section>

					<section id="array-keys" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
zend_hash_update(ht, "key", 4, &amp;zv, sizeof(zval *), NULL);
zend_hash_find(ht, "key", 4, &amp;zv);
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_string *key = zend_string_init("key", 3, 0);

zend_hash_update(ht, key, zv);
zv = zend_hash_find(ht, key);

zend_string_release(key);
						</code></pre>
						<aside class="notes">
							This is a good'un. Array keys in PHP 5 included the null
							terminator in their length because&hellip; hell if I know. In PHP
							7, they don't (partly because we're using zend_strings). You'll
							also note that the API has changed significantly (for the better,
							since it removes a bunch of parameters nobody ever used).
						</aside>
					</section>

					<section id="is-ptr" data-state="translucent" data-background="translucent">
						<h2><code>IS_PTR</code></h2>
						<pre><code class="c" data-trim>
zend_string *key;
my_struct *ptr;

zend_hash_update_ptr(ht, key, ptr);
ptr = (my_struct *) zend_hash_find_ptr(ht, key);
						</code></pre>
						<aside class="notes">
							There's another aspect to this too: you would have noticed that
							we didn't provide the size. The reason for this is because
							HashTables now store zval pointers only. Instead, to store a raw
							pointer, you use a parallel API that internally wraps the pointer
							in a zval with the new IS_PTR type. 
						</aside>
					</section>

					<section id="hashtable-options" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
zval *
compat_zend_hash_find(HashTable *ht, const char *key, size_t len) {
#if ZEND_MODULE_API_NO &gt;= 20151012
	zend_string *zs = zend_string_init(key, len);
	zval *val = zend_hash_find(ht, zs);
	zend_string_release(zs);
	return val;
#else
	zval *val = NULL;
	int res = zend_hash_find(ht, key, len + 1, &amp;val);
	return (res == SUCCESS) ? val : NULL;
#endif
}
						</code></pre>
						<aside class="notes">
							This one's tricky to shim between versions. So far, everyone I've
							seen who's done it has written wrappers with different names
							&amp; you can add the _ptr functions easily enough to PHP 5, but
							that doesn't help with the other API changes. You need to audit
							all zend_hash function calls and figure out if you want to DIY or
							pull in a compatibility helper.
						</aside>
					</section>

					<section id="hashtable-iteration" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
HashPosition pos;
ulong num_key;
char *key;
uint key_len;
zval **zv_pp;

zend_hash_internal_pointer_reset_ex(&amp;ht, &amp;pos);
while (zend_hash_get_current_data_ex(&amp;ht, &amp;zv_pp, &amp;pos)
       == SUCCESS) {
	if (zend_hash_get_current_key_ex(&amp;ht, &amp;key, &amp;key_len,
	                                 &amp;num_key, 0, &amp;pos) ==
	                                 HASH_KEY_IS_STRING) {
		...
	}
}
						</code></pre>
						<aside class="notes">
							One amazing new feature that I want to highlight, even though
							it's not directly a migration topic: HashTables now have these
							incredible iteration macros. If you've had to iterate an array
							before, you'll understand why this is a big deal. Here's the old
							code...
						</aside>
					</section>

					<section id="hashtable-iteration7" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
ulong num_key;
zend_string *key;
zval *zv;

ZEND_HASH_FOREACH_KEY_VAL(ht, num_key, key, val) {
	if (key) {
		...
	}
}
						</code></pre>
						<aside class="notes">
							Here's the new.
						</aside>
					</section>
				</section>

				<section data-background="images/resources.jpg">
					<section id="resources">
						<aside class="notes">
							Let's talk about resources, those weird holdovers from the old
							days. As I mentioned earlier, they're actually a fair bit nicer
							to use, but that doesn't necessarily mean that you want to.
						</aside>
					</section>

					<section id="resource-api" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
int zend_register_resource(zval *zv, void *ptr, int type);
void *zend_fetch_resource(zval **id, int default_id,
                          const char *name, int type,
													int num_types, ...);
int zend_list_delete(int id);
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_resource *zend_register_resource(void *ptr, int type);
void *zend_fetch_resource_ex(zend_resource *res, const char *name,
                             int type);
int zend_list_close(zend_resource *res);
						</code></pre>
						<aside class="notes">
							There were a set of macros on PHP 5 that mapped to the underlying
							functions. As you can see, the functions have changed a tonne for
							the better, but you can't really shim them in any meaningful way,
							particularly since zend_register_resource() changed the zval on
							PHP 5 but doesn't on PHP 7.  On the bright side, the basic
							workflow hasn't really changed: you register a pointer, fetch it,
							and delete/close it.
						</aside>
					</section>

					<section id="resource-options" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
#if ZEND_MODULE_API_NO &gt;= 20151012
#define ZEND_REGISTER_RESOURCE(zv, ptr, type) \
	ZVAL_RES(zv, zend_register_resource(ptr, type));

#define ZEND_FETCH_RESOURCE(zv, type, id, default_id, name, type) \
	zend_fetch_resource_ex(zv, name, type);

#define ZEND_CLOSE_RESOURCE(zv) \
	zend_list_close(Z_RES_P(zv))
#else
#define ZEND_CLOSE_RESOURCE(zv) \
	zend_list_delete(Z_LVAL_P(zv))
#endif
						</code></pre>
						<aside class="notes">
							Your options are either to write a wrapper like the hashtable
							wrapper, or reimplement the macros on PHP 7. I personally prefer
							the wrapper option (and implemented it in pecl-compat), but
							here's a rough version of the macros if you'd prefer that (the
							ignored values are unfortunate).
						</aside>
					</section>
				</section>

				<section data-background="images/object.jpg">
					<section id="objects">
						<aside class="notes">
							Let's talk about objects. Basic object handling is largely
							unchanged, mercifully.
						</aside>
					</section>

					<section id="properties" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
zval *zv;

zv = zend_read_property(ce, obj, name, strlen(name), 0);
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zval rv;
zval *zv;

zv = zend_read_property(ce, obj, name, strlen(name), 0, &amp;rv);
						</code></pre>
						<aside class="notes">
							The one common API that has changed a bit is reading properties.
							In PHP 7, you have to provide the storage for the returned value
							(this is only used if there's a __get method or a custom
							read_property, and you should use the return value "zv" and not
							access "rv").
						</aside>
					</section>

					<section id="properties-options" data-state="translucent" data-background="translucent">
						<pre><code class="c" data-trim>
zval *
compat_zend_read_property(zend_class_entry *ce, zval *obj,
                          const char *name, int name_length,
                          int silent, zval *rv TSRMLS_DC) {
#if ZEND_MODULE_API_NO &gt;= 20151012
	return zend_read_property(ce, obj, name, name_length,
	                          silent, rv);
#else
	(void) rv;
	return zend_read_property(ce, obj, name, name_length,
	                          silent TSRMLS_CC);
#endif
}
						</code></pre>
						<aside class="notes">
							As zend_read_property isn't a macro, you'll have to add a shim.
							I'd go with a little inline function or macro, assuming you're
							writing your own.
						</aside>
					</section>
				</section>

				<section data-background="images/custom-object.jpg">
					<section id="custom-objects">
						<aside class="notes">
							As I mentioned earlier, there is a difference with objects with
							custom allocators because the zend_object struct is variable
							length (to cope with properties).
						</aside>
					</section>

					<section id="custom-objects5-create" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim style="font-size: 1.1em">
typedef struct {
	zend_object std;
	my_struct *struct;
} my_object;

zend_object_value my_object_new(zend_class_entry *ce TSRMLS_DC) {
	my_object *intern;
	zend_object_value retval;

	intern = emalloc(sizeof(my_object));
	/* ... */
	retval.handle = zend_objects_store_put(intern,
		zend_objects_destroy_object, my_object_free, NULL TSRMLS_CC);
	return retval;
}
						</code></pre>
						<aside class="notes">
							In PHP 5, the start of a create_object handler looks like this
							(in general, they have lots of boilerplate). You allocate the
							structure, and then you later register it in the object store and
							return that value. (Also the only slide with smaller text.
							Sorry.)
						</aside>
					</section>

					<section id="custom-objects5-get" data-state="translucent" data-background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
typedef struct {
	zend_object std;
	my_struct *struct;
} my_object;

my_object *my_object_get(zval *zv TSRMLS_DC) {
	return (my_object *)
		zend_object_store_get_object(zv TSRMLS_CC);
}
						</code></pre>
						<aside class="notes">
							Retrieving an object was easy: you'd just cast what you got back
							from the object store.
						</aside>
					</section>

					<section id="custom-objects7-create" data-state="translucent" data-background="translucent">
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
typedef struct {
	my_struct *struct;
	zend_object std;
} my_object;

zend_object *my_object_new(zend_class_entry *ce) {
	struct my_object *intern;

	intern = emalloc(sizeof(my_object) +
	                 zend_objects_properties_size(ce));
	/* ... */
	return &amp;intern-&gt;std;
}
						</code></pre>
						<aside class="notes">
							The PHP 7 version of create_object has three major differences.
							Firstly, we've reordered the structure fields: the zend_object
							has to be the last element now because it's variable length.
							Secondly, there's the emalloc: you have to add the variable space
							required for the class's declared properties. Finally, you don't
							call zend_objects_store_put any more: you return a pointer to the
							zend_object buried within your structure.
						</aside>
					</section>

					<section id="custom-objects7-get" data-state="translucent" data-background="translucent">
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
typedef struct {
	my_struct *struct;
	zend_object std;
} my_object;

my_object *my_object_get(zval *zv) {
	zend_object *obj = Z_OBJ_P(zv);

	return (my_object *)
		((char *)(obj) - XtOffsetOf(my_object, std));
}
						</code></pre>
						<aside class="notes">
							Oh. Oh no.
							<br>
							The getter is more complicated than before. The zend_object
							pointer within the zval points partway through our struct, so we
							use XtOffsetOf to calculate how far back we have to go. The char
							* is because offsetof returns a value in bytes. XtOffsetOf
							instead of offsetof is because of ancient compilers.
						</aside>
					</section>

					<section id="custom-objects7-offset" data-state="translucent" data-background="translucent">
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_class_entry *my_object_ce;
zend_object_handlers my_object_handlers;

PHP_MINIT_FUNCTION(my_extension) {
	zend_class_entry ce;

	INIT_CLASS_ENTRY(ce, "My\\Object", NULL);
	my_object_ce = zend_register_internal_class_ex(&amp;ce, NULL);

	memcpy(&amp;my_object_handlers, &amp;std_object_handlers,
	       sizeof(zend_object_handlers));
	my_object_handlers.offset = XtOffsetOf(my_object, std);
}
						</code></pre>
						<aside class="notes">
							There's one other wrinkle, too, in PHP 7. You have to set the new
							offset field on the object handlers structure to the offset of
							your zend_object within your custom structure. This allows PHP to
							free your entire structure when the object is deleted (although
							you still have to free anything else you've allocated and pointed
							to). The reality is that you're going to have two versions of
							stuff to support both versions.
						</aside>
					</section>
				</section>

				<section id="tsrmls">
					<ul>
						<li><s><code>TSRMLS_C</code></s></li>
						<li><s><code>TSRMLS_CC</code></s></li>
						<li><s><code>TSRMLS_D</code></s></li>
						<li><s><code>TSRMLS_DC</code></s></li>
						<li><s><code>TSRMLS_FETCH</code></s></li>
					</ul>
					<aside class="notes">
						The last change I'll talk about is the one that renamed the talk:
						TSRMLS macros are no more in PHP 7. They've been preserved solely
						to ensure that you don't have to remove them if you're supporting
						both versions, but for PHP 7 only code, you can rip them out.
					</aside>
				</section>

				<section data-background="images/tools.jpg">
					<section id="tools">
						<aside class="notes">
							Finally, let's look at a few tools and references that I've
							personally found useful.
						</aside>
					</section>

					<section id="phpng-upgrading" data-state="translucent" data-background="translucent">
						<h2>phpng-upgrading</h2>
						<a href="https://wiki.php.net/phpng-upgrading">
							https://wiki.php.net/phpng-upgrading
						</a>
						<aside class="notes">
							The absolute best guide available today is the phpng upgrading
							guide on the php.net wiki. It's not perfect, but it covers a lot
							of things I've talked about in more depth, and covers a lot more
							too.
						</aside>
					</section>

					<section id="lxr" data-state="translucent" data-background="translucent">
						<h2>LXR</h2>
						<a href="http://lxr.php.net/">
							http://lxr.php.net/
						</a>
						<img src="images/lxr.png">
						<aside class="notes">
							LeXeR is a great tool for seeing how definitions and prototypes
							change between versions. Enter a definition, select PHP_5_6 and
							PHP_7_0, and you know how it changed!
						</aside>
					</section>

					<section id="git" data-state="translucent" data-background="translucent">
						<h2><span class="octicon octicon-git-compare"></span></h2>
						<code>git diff PHP-5.6..PHP-7.0 ext/gmp</code>
						<aside class="notes">
							Comparing other extensions before and after PHP 7 support is a
							really useful tool too. You can do it with a Git checkout of
							php-src easily: pick an extension that does something like what
							you want, and diff PHP-5.6 to PHP-7.0. Or find a PECL extension
							and compare side by side.
						</aside>
					</section>

					<section id="pecl-compat" data-state="translucent" data-background="translucent">
						<h2>pecl-compat</h2>
						<a href="https://github.com/flaupretre/pecl-compat/">
							https://github.com/flaupretre/pecl-compat/
						</a>
						<aside class="notes">
							Francois Laupretre has written a set of headers called
							pecl-compat that you can pull into your project (I've done so in
							PECL radius through a submodule). They're not comprehensive, but
							he accepts pull requests happily, and where possible, this shims
							PHP 5 APIs so you can write PHP 7 code, and provides
							compatibility functions or macros where not. Object support would
							be great!
						</aside>
					</section>
				</section>

				<section data-background="images/afraid.jpg">
					<section id="fear">
						<aside class="notes">
							Don't be afraid. Upgrading looks scary when you first see what's
							changed, and the compiler errors when you first try to build your
							extension against PHP 7, but it's really not that bad. I did RADIUS
							in a pretty lazy afternoon, and nine out of ten PHP contributors
							agree that I write terrible code. (Ask Nikita about my CSV code.)
							If you're methodical, you'll have no problem.
						</aside>
					</section>

          <section id="questions" data-state="translucent" data-background="translucent">
            <h1>Thank you!</h1>
            <h2>Questions?</h2>
						<p><a href="https://twitter.com/LGnome">@LGnome</a></p>
						<p>
							Slides:
							<a href="https://lawngnome.github.io/rip-tsrmls-cc/">
								https://lawngnome.github.io/rip-tsrmls-cc/
							</a>
						</p>
						<aside class="notes">
							Go to image credits.
						</aside>
          </section>

          <section id="image-credits" data-state="translucent" data-background="translucent">
            <h2>Image credits</h2>
            <div></div>
          </section>
        </section>
			</div>
		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

    <script src="js/jquery-2.2.0.min.js"></script>
    <script src="js/images.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: (-1 == window.location.host.indexOf("localhost") && -1 == window.location.host.indexOf("0.0.0.0")),
				progress: false,
				history: true,
				center: true,
				width: 1280,
				height: 720,

				transition: 'fade', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true }
				]
			});

      $("#image-credits > div").imageCredits();

		</script>
	</body>
</html>
<!-- vim: set nocin ai noet ts=2 sw=2: -->
