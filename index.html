<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>RIP TSRMLS_CC</title>

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="reveal.js/css/reveal.css">
		<link rel="stylesheet" href="reveal.js/css/theme/sky.css" id="theme">

		<!-- CSS overrides -->
		<link rel="stylesheet" href="css/style.css">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="reveal.js/lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'reveal.js/css/print/pdf.css' : 'reveal.js/css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

		<!--[if lt IE 9]>
		<script src="reveal.js/lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<div class="slides">
				<section id="title">
          <h2>Welcome to the new age</h2>
					<h1>RIP <code>TSRMLS_CC</code></h1>
					<h3>
						Adam Harvey
						<br>
						<a href="https://twitter.com/LGnome">@LGnome</a>
						<br>
						<a href="http://newrelic.com">New Relic</a>
					</h3>
				</section>

				<section data-background="images/Woolly_mammoth.jpg">
					<section id="php7">
						<aside class="notes">
							PHP 7 came out in December 2015. It's been kept quiet, but you
							may have heard of it.
						</aside>
					</section>

					<section id="api-churn" data-background="translucent">
						<h2>API churn</h2>
						<ul>
							<li>333 functions/macros removed</li>
							<li>410 functions/macros added</li>
						</ul>
						<aside class="notes">
							In userland, we did a good job of maintaining backward
							compatibility, but that wasn't the case for the API exposed by
							the Zend Engine and PHP itself. 333 functions is almost exactly
							one quarter of the functions and macros exposed by PHP 5.6.
						</aside>
					</section>

					<section id="api-diff" data-background="translucent">
						<h2>API churn</h2>
						<ul>
							<li>516 out of 990 functions/macros differ</li>
						</ul>
            <aside class="notes">
              Here's the more insidious bit: more than half of the functions
              that kept the same name have changed. (And that excluded
              TSRM-related noise.) Different types, different numbers of
              parameters, different return values. Most don't matter, but some
              <em>really</em> do.
            </aside>
					</section>
				</section>

        <section data-background="images/geograph-3799604-by-Peter-.jpg">
          <section id="what-do">
            <aside class="notes">
              So, now that I've thoroughly terrified you, what do you do with
              your PHP 4 or 5 era extension that your site relies on?
            </aside>
          </section>

          <section id="options" data-background="translucent">
            <h2>What do?</h2>
            <ul>
              <li>One way migration</li>
              <li>Separate branches</li>
              <li>Shared codebase</li>
              <li class="fragment">Ignore PHP 7 and hope it goes away</li>
            </ul>
            <aside class="notes">
              The way I see it, you have three real options.
              (pause)
              I guess there's a fourth.
            </aside>
          </section>
        </section>

        <section data-background="images/road-street-sign-way.jpg">
          <section id="one-way">
          </section>
          <aside class="notes">
            Let's look at the pros and cons of each in turn. First up: one way
            migration.
          </aside>

          <section id="one-way-advantages" data-background="translucent">
            <h2>Advantages</h2>
            <ul>
              <li>One time cost</li>
              <li>Conceptually simple</li>
              <li>Cleaner code</li>
            </ul>
          </section>

          <section id="one-way-disadvantages" data-background="translucent">
            <h2>Disadvantages</h2>
            <ul>
              <li>You no longer support PHP 5</li>
            </ul>
            <aside class="notes">
              Not supporting PHP 5 may not be a huge issue if you're only
              supporting something internal: if you're planning to do a hard
              cut over, that works. Although I'm not going to talk a lot about
              this option as we go on, the things I highlight are also things
              you'd want to do with this option.
            </aside>
          </section>
        </section>

        <section data-background="images/branches.jpg">
          <section id="branches">
            <aside class="notes">
              Maintaining parallel branches is another option.
            </aside>
          </section>

          <section id="branches-advantages" data-background="translucent">
            <h2>Advantages</h2>
            <ul>
              <li>Both versions are supported</li>
              <li>Able to write idiomatic code for both versions</li>
            </ul>
          </section>

          <section id="branches-disadvantages" data-background="translucent">
            <h2>Disadvantages</h2>
            <ul>
              <li>Maintenance is a pain</li>
              <li>Potentially double the work</li>
              <li>Branches may diverge over time</li>
            </ul>
            <aside class="notes">
              This might work if you have almost everything abstracted away,
              but if you do, the parts of your code that interface with PHP are
              probably so simple anyway that you could just support both
              versions in the one branch.
            </aside>
          </section>
        </section>

        <section data-background="images/hammer.jpg">
          <section id="shared">
            <aside class="notes">
              Finally (excluding ignoring PHP 7), you can run a shared codebase.
            </aside>
          </section>

          <section id="shared-advantages" data-background="translucent">
            <h2>Advantages</h2>
            <ul>
              <li>Both versions are supported</li>
              <li>Less maintenance overhead</li>
              <li>Happy users</li>
            </ul>
            <aside class="notes">
              Happy users because they can just download the latest release; cf
              memcached.
            </aside>
          </section>

          <section id="shared-disadvantages" data-background="translucent">
            <h2>Disadvantages</h2>
            <ul>
              <li>So many API changes</li>
            </ul>
            <aside class="notes">
              I'm going to delve deeper into this. There are ways you can
              mitigate the API changes &mdash; how hard it is depends a lot on
              what type of extension you're writing. Simple C library wrappers:
              not too bad. Deep voodoo magic extensions: bad (but still
              doable).
            </aside>
          </section>
        </section>

        <section id="no-really-what-do-i-do" data-background="images/geograph-3799604-by-Peter-.jpg">
					<aside class="notes">
						As I've touched on already, it depends on your use case. If you're
						doing a flag day cutover of your app, and you have an extension
						that solely exists to serve that app, you probably just want to do
						a one way migration and be done with it. Otherwise, I'd go for
						option 3: support both. Separate branches don't work in the long
						term: ask Python developers.
					</aside>
				</section>

				<section data-background="images/fix.jpg">
					<section id="problems">
						<aside class="notes">
							So we know that a lot changed. What do we need to look for when
							migrating an extension?
						</aside>
					</section>

					<section id="zval" data-background="translucent">
						<h2><code>zval</code></h2>
						<aside class="notes">
							Let's start from the inside and work our way out. Many of the
							changes that matter when working on an extension are
							fundamentally type-related, so let's start with the type that
							underpins all of PHP.
						</aside>
					</section>

					<section id="zval-struct" data-background="translucent">
						<pre><code class="c" data-trim>
typedef struct {
	zend_uchar type;
	zend_uint  refcount__gc;
	zend_uchar is_ref__gc;
	union {
		long lval;
		double dval;
		struct {
			char *val;
			int len;
		} str;
		HashTable *ht;
		zend_object_value obj;
	} value;
} zval;
						</code></pre>
						<aside class="notes">
							Here's a simplified version of what the zval struct looks like in
							PHP 5. The important thing to remember is that each type
							corresponds to a member in the value union. Many of these values
							have changed: either in structure or in type.
						</aside>
					</section>

					<section id="zval-struct7" data-background="translucent">
						<pre><code class="c" data-trim>
typedef struct {
	zend_value value;
	union {
		struct {
			zend_uchar type;
			...
		}
	}
} zval;
						</code></pre>
						<aside class="notes">
							Here's a simplified version of the PHP 7 zval. We'll talk about
							the specifics of the types that have changed representation after
							this, but I want you to note that the refcount and is_ref fields
							are gone. zvals are passed around by value rather than reference,
							so simple types don't need to be refcounted, and types that do
							need to be are refcounted within their values rather than the
							zval itself.
						</aside>
					</section>

					<section id="zval-long" data-background="translucent">
						<h2><code>IS_LONG</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
long lval;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_long lval;

#if defined(__LP64__) || defined(_LP64) || defined(_WIN64)
typedef int64_t zend_long;
#else
typedef int32_t zend_long;
#endif
						</code></pre>
						<aside class="notes">
							Integers are now this zend_long type, which means that integers
							are now consistently 64 bit on all 64 bit platforms, including
							Windows (which used to be an oddball).
						</aside>
					</section>

					<section id="zval-bool" data-background="translucent">
						<h2><code>IS_BOOL</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
long lval;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
#define IS_FALSE 2
#define IS_TRUE  3

ZEND_API int zend_is_true(zval *op);
						</code></pre>
						<aside class="notes">
							IS_BOOL is gone altogether! In PHP 5, it used the lval to
							indicate whether it was true or false. In PHP 7, false and true
							are separate types. The ZVAL_BOOL macro still exists for setting,
							but to check the value you either have to check the type or call
							zend_is_true().
						</aside>
					</section>

					<section id="zval-string" data-background="translucent">
						<h2><code>IS_STRING</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
struct {
	char *val;
	int len;
} str;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_string *str;
						</code></pre>
						<aside class="notes">
							I'm going to come back to this zend_string structure shortly. The
							Zend Engine has retained the Z_STRLEN and Z_STRVAL macros, but
							there's now a string structure that gets used throughout the
							engine, not just for zvals. One thing to know right now: lengths
							are now size_t, not int.
						</aside>
					</section>

					<section id="zval-object" data-background="translucent">
						<h2><code>IS_OBJECT</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
zend_object_value obj;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_object *obj;
						</code></pre>
						<aside class="notes">
							Another new type! Again, I'll come back to zend_object, but the
							important thing to note is that it's now just a pointer, rather
							than a small inline structure with an index into another
							hashtable.
						</aside>
					</section>

					<section id="zval-resource" data-background="translucent">
						<h2><code>IS_RESOURCE</code></h2>
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
long lval;
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
zend_resource *res;
						</code></pre>
						<aside class="notes">
							Similarly, resources change from being indexes stored in the long
							value to being pointers to their own structures, which I'll
							describe more fully in a bit.
						</aside>
					</section>

					<section id="zval-new-types" data-background="translucent">
						<pre><code class="c" data-trim>
#define IS_UNDEF     0

#define IS_REFERENCE 10
zend_reference *ref;
						</code></pre>
						<aside class="notes">
							Finally, there are a bunch of new types. The two that are
							important are UNDEF, which is for undefined variables (as the
							name might suggest), and REFERENCE, which replaces the built in
							is_ref field in the zval with a pointer to a refcounted
							structure (remembering the earlier point about not having
							refcounting in the zval itself).
						</aside>
					</section>
				</section>

				<section data-background="red">
					<section id="parameter-parsing">
						<aside class="notes">
							One area where this matters is parameter parsing. If you continue
							giving the old types to zend_parse_parameters, particularly with
							strings, you'll end up with garbage because type sizes have
							changed.
						</aside>
					</section>

					<section id="zpp-string" background="translucent">
						<h3>PHP 5</h3>
						<pre><code class="c" data-trim>
char *str;
int len;

zend_parse_parameters(ZEND_NUM_ARGS(), "s", &amp;str, &amp;len);
						</code></pre>
						<h3>PHP 7</h3>
						<pre><code class="c" data-trim>
char *str;
size_t len;

zend_parse_parameters(ZEND_NUM_ARGS(), "s", &amp;str, &amp;len);
						</code></pre>
						<aside class="notes">
							For example: as I mentioned earlier, string lengths are now
							size_t. If you don't change the length variable to size_t, you
							get interesting looking segfaults on 64 bit platforms. This one's
							insidious.
						</aside>
					</section>

					<section id="zpp-string-options" background="translucent">
						<pre><code class="c" data-trim>
#if ZEND_MODULE_API_NO &gt;= 20151012
typedef size_t zend_string_len_t;
#else
typedef int zend_string_len_t;
#endif
						</code></pre>
						<aside class="notes">
							How do you deal with this if you want to support both versions?
							You can do some macro and typedef magic.
						</aside>
					</section>
				</section>

        <section>
          <section id="questions">
            <h1>Thank you!</h1>
            <h2>Questions?</h2>
						<a href="https://twitter.com/LGnome">@LGnome</a>
          </section>

          <section id="image-credits">
            <h2>Image credits</h2>
            <div></div>
          </section>
        </section>
			</div>
		</div>

		<script src="reveal.js/lib/js/head.min.js"></script>
		<script src="reveal.js/js/reveal.js"></script>

    <script src="js/jquery-2.2.0.min.js"></script>
    <script src="js/images.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: (-1 == window.location.host.indexOf("localhost") && -1 == window.location.host.indexOf("0.0.0.0")),
				progress: false,
				history: true,
				center: true,
				width: 1280,
				height: 720,

				transition: 'fade', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'reveal.js/plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'reveal.js/plugin/notes/notes.js', async: true }
				]
			});

      $("#image-credits > div").imageCredits();

		</script>
	</body>
</html>
<!-- vim: set nocin ai noet ts=2 sw=2: -->
